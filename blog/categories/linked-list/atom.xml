<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linked list | lightsaber]]></title>
  <link href="http://xiaochenchen.github.io/blog/categories/linked-list/atom.xml" rel="self"/>
  <link href="http://xiaochenchen.github.io/"/>
  <updated>2014-03-25T00:34:48-04:00</updated>
  <id>http://xiaochenchen.github.io/</id>
  <author>
    <name><![CDATA[lightsaber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[leetcode] Merge k Sorted Lists]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/25/leetcode-merge-k-sorted-lists/"/>
    <updated>2014-03-25T00:21:55-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/25/leetcode-merge-k-sorted-lists</id>
    <content type="html"><![CDATA[<h4>Main idea is to divide and conquer.</h4>

<p>Divide the k lists into group of 2. Merge every 2 to get (k+1)/2 lists. Then run the same process again until there is only one list left.</p>

<h4>Note the sub-problem here: Merge two sorted linked list.</h4>

<blockquote><p>Time Complexity: O(log(k)kn) where k is the number lists and n is the average length of list
``` java Merge k Sorted Lists <a href="http://oj.leetcode.com/problems/merge-k-sorted-lists/">http://oj.leetcode.com/problems/merge-k-sorted-lists/</a> Leetcode Link
/<em>*
 * Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
 *
 * Created by lightsaber on 3/23/14.
 </em>/
public class MergeKSortedList
{</p>

<pre><code>// Definition for singly-linked list.
public class ListNode {
    int val;
    ListNode next;
</code></pre></blockquote>

<pre><code>    ListNode(int x) {
        val = x;
        next = null;
    }
}

public ListNode mergeKLists(ArrayList&lt;ListNode&gt; lists) {

    if(lists == null || lists.size() == 0)
    {
        return null;
    }

    int listSize = lists.size();

    while(listSize &gt; 1)
    {
        // merge two lists at a time, set into lists from the beginning
        for(int i = 0; i &lt; listSize / 2; ++i)
        {
            ListNode listA = lists.get(2 * i);
            ListNode listB = lists.get(2 * i + 1);
            lists.set(i, mergeTwoLists(listA, listB));
        }

        // if there is one list left at last
        if(listSize % 2 != 0)
        {
            // pay attention to the index, max index = size - 1
            lists.set(listSize / 2, lists.get(listSize - 1));
        }

        // calculate list size for next iteration
        listSize = (listSize + 1) / 2;
    }

    return lists.get(0);
}

/**
 * merge two sorted linked list in place
 * @param listA
 * @param listB
 * @return
 */

public ListNode mergeTwoLists(ListNode listA, ListNode listB)
{
    // add dummy head to keep track of the start of the list
    ListNode dummyHead = new ListNode(Integer.MIN_VALUE);
    ListNode curTail = dummyHead;

    while(true)
    {
        // stop point of the loop
        // if we reach the end of either list
        if(listA == null)
        {
            curTail.next = listB;
            break;
        }
        else if(listB == null)
        {
            curTail.next = listA;
            break;
        }

        if(listA.val &lt; listB.val)
        {
            curTail.next = listA;
            listA = listA.next;
        }
        else
        {
            curTail.next = listB;
            listB = listB.next;
        }

        curTail = curTail.next;
    }

    // return the node right after dummyHead
    return dummyHead.next;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[leetcode] Remove Nth Node From End of List]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/23/leetcode-remove-nth-node-from-end-of-list/"/>
    <updated>2014-03-23T16:28:30-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/23/leetcode-remove-nth-node-from-end-of-list</id>
    <content type="html"><![CDATA[<blockquote><p>Assumption:
Given n will always be valid.</p></blockquote>

<h4>Two things to pay attention to during implementation:</h4>

<ol>
<li>add a dummy head pointer to avoid special processing for the case when head is null</li>
<li>keep track of the node (call it B) before the target node, check if B.next is null before removing the target node</li>
</ol>


<p>Also notice that the index start from 1 from the end of the list.
``` java Remove Nth Node From End of List <a href="http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">http://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/</a> Leetcode Link
/<em>*
 * Given a linked list, remove the nth node from the end of list and return its head.
 * For example,
 *  Given linked list: 1->2->3->4->5, and n = 2.
 *  After removing the second node from the end, the linked list becomes 1->2->3->5.
 *
 * Solution:
 *  Start with a A pointer from the head, once A is pointing to Nth node
 *  introduce pointer start from head, move A and B together until A gets to the end
 *  And now remove the node after B.
 *
 </em>/
public class RemoveNthNodeFromEndOfList {</p>

<pre><code>// Definition for singly-linked list.
public class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

public ListNode removeNthFromEnd(ListNode head, int n)
{
    // introduce dummy head to ignore the null list input case
    ListNode dummyHead = new ListNode(Integer.MIN_VALUE);
    dummyHead.next = head;

    // A pointer
    ListNode aNode = dummyHead;
    // index of the A pointer
    int aIndex = 0;

    // advance A pointer to N node away from head
    while(aIndex &lt; n &amp;&amp; aNode.next != null)
    {
        aNode = aNode.next;
        aIndex++;
    }

    // B pointer
    ListNode bNode = dummyHead;

    // advance A and B at the same time, until A gets the the end
    while(aNode.next != null)
    {
        aNode = aNode.next;
        bNode = bNode.next;
    }

    // remove the Node after B, which is Nth away from the end
    // only when bNode.next is not NULL
    if(bNode.next != null)
    {
        bNode.next = bNode.next.next;
    }

    return dummyHead.next;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
