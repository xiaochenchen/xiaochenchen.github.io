<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: coding | lightsaber]]></title>
  <link href="http://xiaochenchen.github.io/blog/categories/coding/atom.xml" rel="self"/>
  <link href="http://xiaochenchen.github.io/"/>
  <updated>2014-03-30T14:49:04-04:00</updated>
  <id>http://xiaochenchen.github.io/</id>
  <author>
    <name><![CDATA[lightsaber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[leetcode] Generate Parentheses]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/30/leetcode-generate-parentheses/"/>
    <updated>2014-03-30T14:46:33-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/30/leetcode-generate-parentheses</id>
    <content type="html"><![CDATA[<h3>Algorithm:</h3>

<p>Recursion, keep track of leftCount and rightCount. Decide to only append left or both.
``` java Generate Parentheses <a href="http://oj.leetcode.com/problems/generate-parentheses/">http://oj.leetcode.com/problems/generate-parentheses/</a> Leetcode Link
/<em>*
 *
 * Given n pairs of parentheses,
 * write a function to generate all combinations of well-formed parentheses.
 *
 *      For example, given n = 3, a solution set is:
 *      &ldquo;((()))&rdquo;, &ldquo;(()())&rdquo;, &ldquo;(())()&rdquo;, &ldquo;()(())&rdquo;, &ldquo;()()()&rdquo;
 *
 * Created by lightsaber on 3/29/14.
 </em>/
public class GenerateParentheses
{</p>

<pre><code>public ArrayList&lt;String&gt; generateParentheses(int n)
{
    ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();
    StringBuilder sb = new StringBuilder();
    generate(results, sb, n, n);
    return results;
}

public void generate(ArrayList&lt;String&gt; results, StringBuilder result, int lc, int rc)
{
    // end of one combination, add to the result set and return
    if(lc == 0 &amp;&amp; rc == 0)
    {
        results.add(result.toString());
        return;
    }

    if(lc &gt; 0)
    {
        result.append("(");
        generate(results, result, lc - 1, rc);
        result.deleteCharAt(result.length() - 1);
    }

    if(lc &lt; rc)
    {
        result.append(")");
        generate(results, result, lc, rc - 1);
        result.deleteCharAt(result.length() - 1);
    }
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[leetcode] Longest Consecutive Sequence]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/30/leetcode-longest-consecutive-sequence/"/>
    <updated>2014-03-30T14:23:31-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/30/leetcode-longest-consecutive-sequence</id>
    <content type="html"><![CDATA[<h3>Algorithm:</h3>

<p>Store all elements in an HashSet H.
Start scaning the array, for each element i in the array, if i is in H, check whether i-1 is in H, if yes, remove i-1 from H, continue to check i &ndash; 2 and not found in H. Do the same thing from i to its right. Keep track of current max length. Return max length at the end.
``` java Longest Consecutive Sequence <a href="http://oj.leetcode.com/problems/longest-consecutive-sequence/">http://oj.leetcode.com/problems/longest-consecutive-sequence/</a> Leetcode Link
/<em>*
 *
 * Given an unsorted array of integers,
 * find the length of the longest consecutive elements sequence.
 *
 * For example,
 * Given [100, 4, 200, 1, 3, 2],
 * The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
 * Your algorithm should run in O(n) complexity.
 *
 * Created by lightsaber on 3/27/14.
 </em>/
public class LongestConsecutiveSequence
{</p>

<pre><code>public int longestConsecutive(int[] num)
{
    Set&lt;Integer&gt; numbers = new HashSet&lt;Integer&gt;();
    for(int i : num)
    {
        numbers.add(i);
    }

    int longest = 0;
    for(int i : num)
    {
        if(numbers.contains(i))
        {
            int left = i, right = i;

            while(numbers.contains(left - 1))
            {
                numbers.remove(--left);
            }

            while(numbers.contains(right + 1))
            {
                numbers.remove(++right);
            }

            if(right - left + 1 &gt; longest)
            {
                longest = right - left + 1;
            }
        }
    }

    return longest;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[leetcode] Implement strStr()]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/27/leetcode-implement-strstr/"/>
    <updated>2014-03-27T22:47:45-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/27/leetcode-implement-strstr</id>
    <content type="html"><![CDATA[<h3>Algorithm</h3>

<p>brute force, stop matching when the remaining string in source is shorter than target
There is KMP algorithm, if you are interested. Not implementing here.
``` java Implement strStr() <a href="http://oj.leetcode.com/problems/implement-strstr/">http://oj.leetcode.com/problems/implement-strstr/</a> Leetcode Link
/<em>*
 *
 * Implement strStr().
 * Returns a pointer to the first occurrence of needle in haystack,
 * or null if needle is not part of haystack.
 *
 * Created by lightsaber on 3/27/14.
 </em>/
public class StrStr
{</p>

<pre><code>public String strStr(String haystack, String needle) {
    for(int i = 0; i &lt;= haystack.length() - needle.length(); ++i)
    {
        if(haystack.substring(i, i + needle.length()).equals(needle))
        {
            return haystack.substring(i);
        }
    }

    return null;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[leetcode] Reverse Nodes in K Group]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/27/leetcode-reverse-nodes-in-k-group/"/>
    <updated>2014-03-27T22:03:43-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/27/leetcode-reverse-nodes-in-k-group</id>
    <content type="html"><![CDATA[<h3>Algorithm</h3>

<p>This question is similar to <a href="http://xiaochenchen.github.io/blog/2014/03/27/leetcode-swap-nodes-in-pairs/">Swap Nodes in Pairs</a> in that we need to keep track of the Node before the K group, we call it <code>pre</code> reference. When we are done with the K group, we need to change pre to point to the Begin of this K group.</p>

<p>In order to reverse K group, we keep track of the beginning <code>kBegin</code> and ending <code>kEnd</code> of currently reversed nodes. When processing for next node, we move <code>kEnd</code> to point to its next, insert itself before <code>kBegin</code>, and update <code>kBegin</code>. Until we reserverd K nodes.
``` java Reverse Nodes in K Group <a href="http://oj.leetcode.com/problems/reverse-nodes-in-k-group/">http://oj.leetcode.com/problems/reverse-nodes-in-k-group/</a> Leetcode Link
/<em>*
 * Given a linked list, reverse the nodes of the
 * linked list k at a time and return its modified list.
 * If the number of nodes is not a multiple of k
 * then left-out nodes in the end should remain as it is.
 * You may not alter the values in the nodes, only nodes itself may be changed.
 *
 * Only constant memory is allowed.
 *
 * For example,
 * Given this linked list: 1->2->3->4->5
 * For k = 2, you should return: 2->1->4->3->5
 * For k = 3, you should return: 3->2->1->4->5
 *
 * Created by lightsaber on 3/27/14.
 </em>/
public class ReverseNodesInKGroup
{</p>

<pre><code>// Definition for singly-linked list.
public class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

public ListNode reverseKGroup(ListNode head, int k) {

    ListNode dummyHead = new ListNode(Integer.MIN_VALUE);
    dummyHead.next = head;

    ListNode pre = dummyHead;
    ListNode kBegin = head;
    ListNode kEnd = head;

    while(hasAtLeastKNodes(kBegin, k))
    {
        int count = 1;

        while(count &lt; k)
        {
            ListNode temp = kEnd.next.next;
            kEnd.next.next = kBegin;
            kBegin = kEnd.next;
            kEnd.next = temp;
            count++;
        }

        // set the references for next k nodes
        pre.next = kBegin;
        pre = kEnd;
        kBegin = pre.next;
        kEnd = pre.next;
    }

    return dummyHead.next;
}

// utility function to check if there are at least k nodes from head
public boolean hasAtLeastKNodes(ListNode head, int k)
{
    int count = 0;

    ListNode curr = head;
    while(curr != null)
    {
        count++;
        if(count == k)
        {
            return true;
        }
        curr = curr.next;
    }

    return false;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[leetcode] Swap Nodes in Pairs]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/27/leetcode-swap-nodes-in-pairs/"/>
    <updated>2014-03-27T21:19:11-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/27/leetcode-swap-nodes-in-pairs</id>
    <content type="html"><![CDATA[<h3>Algorithm:</h3>

<p>Use a pre reference, to keep track of previous node before current pair.
Swap that pair. Take care of the end of the pair, the pair itself and the node before current pair.
``` java Swap Nodes in Pairs <a href="http://oj.leetcode.com/problems/swap-nodes-in-pairs/">http://oj.leetcode.com/problems/swap-nodes-in-pairs/</a> Leetcode Link
/<em>*
 * Given a linked list, swap every two adjacent nodes and return its head.
 *
 *      For example,
 *      Given 1->2->3->4, you should return the list as 2->1->4->3.
 *
 * Your algorithm should use only constant space.
 * You may not modify the values in the list, only nodes itself can be changed.
 *
 * Created by lightsaber on 3/26/14.
 </em>/
public class SwapNodesInPairs
{</p>

<pre><code>// Definition for singly-linked list.
public class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

public ListNode swapPairs(ListNode head)
{
    ListNode dummyHead = new ListNode(Integer.MIN_VALUE);
    dummyHead.next = head;

    ListNode pre = dummyHead;
    ListNode curr = head;

    while(curr != null &amp;&amp; curr.next != null)
    {
        ListNode temp = curr.next.next;
        curr.next.next = curr;
        pre.next = curr.next;
        curr.next = temp;

        pre = curr;
        curr = curr.next;
    }

    return dummyHead.next;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
