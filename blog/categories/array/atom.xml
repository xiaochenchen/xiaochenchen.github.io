<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: array | lightsaber]]></title>
  <link href="http://xiaochenchen.github.io/blog/categories/array/atom.xml" rel="self"/>
  <link href="http://xiaochenchen.github.io/"/>
  <updated>2014-03-30T14:49:04-04:00</updated>
  <id>http://xiaochenchen.github.io/</id>
  <author>
    <name><![CDATA[lightsaber]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[leetcode] Longest Consecutive Sequence]]></title>
    <link href="http://xiaochenchen.github.io/blog/2014/03/30/leetcode-longest-consecutive-sequence/"/>
    <updated>2014-03-30T14:23:31-04:00</updated>
    <id>http://xiaochenchen.github.io/blog/2014/03/30/leetcode-longest-consecutive-sequence</id>
    <content type="html"><![CDATA[<h3>Algorithm:</h3>

<p>Store all elements in an HashSet H.
Start scaning the array, for each element i in the array, if i is in H, check whether i-1 is in H, if yes, remove i-1 from H, continue to check i &ndash; 2 and not found in H. Do the same thing from i to its right. Keep track of current max length. Return max length at the end.
``` java Longest Consecutive Sequence <a href="http://oj.leetcode.com/problems/longest-consecutive-sequence/">http://oj.leetcode.com/problems/longest-consecutive-sequence/</a> Leetcode Link
/<em>*
 *
 * Given an unsorted array of integers,
 * find the length of the longest consecutive elements sequence.
 *
 * For example,
 * Given [100, 4, 200, 1, 3, 2],
 * The longest consecutive elements sequence is [1, 2, 3, 4]. Return its length: 4.
 * Your algorithm should run in O(n) complexity.
 *
 * Created by lightsaber on 3/27/14.
 </em>/
public class LongestConsecutiveSequence
{</p>

<pre><code>public int longestConsecutive(int[] num)
{
    Set&lt;Integer&gt; numbers = new HashSet&lt;Integer&gt;();
    for(int i : num)
    {
        numbers.add(i);
    }

    int longest = 0;
    for(int i : num)
    {
        if(numbers.contains(i))
        {
            int left = i, right = i;

            while(numbers.contains(left - 1))
            {
                numbers.remove(--left);
            }

            while(numbers.contains(right + 1))
            {
                numbers.remove(++right);
            }

            if(right - left + 1 &gt; longest)
            {
                longest = right - left + 1;
            }
        }
    }

    return longest;
}
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
